# Task ID: 100
# Title: Implement Voice Conversation Persistence with SwiftData
# Status: done
# Dependencies: 99 (Not found), 31 (Not found), 34 (Not found)
# Priority: high
# Description: Create persistent storage for voice conversations using SwiftData, linking them to materials/subjects and ensuring proper UI integration for conversation history.
# Details:
1. Create SwiftData models in Core/Models:
   - VoiceConversation.swift:
     ```swift
     @Model
     final class VoiceConversation {
         var id: UUID
         var title: String
         var createdAt: Date
         var updatedAt: Date
         var subjectID: UUID?
         var materialID: UUID?
         @Relationship(.cascade) var messages: [VoiceMessage]
         
         init(id: UUID = UUID(), title: String, createdAt: Date = Date(), updatedAt: Date = Date()) {
             self.id = id
             self.title = title
             self.createdAt = createdAt
             self.updatedAt = updatedAt
             self.messages = []
         }
     }
     ```
   
   - VoiceMessage.swift:
     ```swift
     @Model
     final class VoiceMessage {
         var id: UUID
         var content: String
         var isUserMessage: Bool
         var timestamp: Date
         var conversation: VoiceConversation?
         
         init(id: UUID = UUID(), content: String, isUserMessage: Bool, timestamp: Date = Date()) {
             self.id = id
             self.content = content
             self.isUserMessage = isUserMessage
             self.timestamp = timestamp
         }
     }
     ```

2. Update VoiceConversationViewModel:
   - Replace volatile array with SwiftData query:
     ```swift
     @Query private var conversations: [VoiceConversation]
     @Query private var currentMessages: [VoiceMessage]
     private var modelContext: ModelContext
     ```
   - Implement CRUD operations:
     ```swift
     func createNewConversation(title: String = "New Conversation") {
         let conversation = VoiceConversation(title: title)
         modelContext.insert(conversation)
         currentConversationID = conversation.id
         try? modelContext.save()
     }
     
     func addUserMessage(_ content: String) {
         guard let conversation = getCurrentConversation() else { return }
         let message = VoiceMessage(content: content, isUserMessage: true)
         conversation.messages.append(message)
         conversation.updatedAt = Date()
         try? modelContext.save()
     }
     
     func addAIMessage(_ content: String) {
         guard let conversation = getCurrentConversation() else { return }
         let message = VoiceMessage(content: content, isUserMessage: false)
         conversation.messages.append(message)
         conversation.updatedAt = Date()
         try? modelContext.save()
     }
     ```

3. Connect microphone transcription to addUserMessage:
   - In the voice conversation view, modify the microphone button action:
     ```swift
     Button(action: {
         if isRecording {
             audioPipeline.stopRecording()
             if let transcription = audioPipeline.currentTranscription {
                 viewModel.addUserMessage(transcription)
             }
         } else {
             audioPipeline.startRecording()
         }
         isRecording.toggle()
     }) {
         // Button UI
     }
     ```

4. Connect AI responses to addAIMessage:
   - In the OpenAIRealtimeClient callback:
     ```swift
     func onMessageReceived(_ message: String) {
         DispatchQueue.main.async {
             self.conversationViewModel.addAIMessage(message)
         }
     }
     ```

5. Load conversation history on view appear:
   - Add to VoiceConversationView:
     ```swift
     .onAppear {
         viewModel.loadConversations()
         if let conversationID = selectedConversationID {
             viewModel.setCurrentConversation(id: conversationID)
         }
     }
     ```

6. Update UI to display conversation history:
   - Modify the ScrollView in VoiceConversationView:
     ```swift
     ScrollView {
         LazyVStack(alignment: .leading, spacing: 12) {
             ForEach(viewModel.currentMessages) { message in
                 MessageBubble(
                     content: message.content,
                     isUserMessage: message.isUserMessage,
                     timestamp: message.timestamp
                 )
             }
         }
         .padding()
     }
     ```

7. Add conversation management features:
   - Create a ConversationListView:
     ```swift
     struct ConversationListView: View {
         @ObservedObject var viewModel: VoiceConversationViewModel
         @State private var searchText = ""
         @State private var selectedSubject: UUID?
         
         var filteredConversations: [VoiceConversation] {
             viewModel.conversations
                 .filter { searchText.isEmpty || $0.title.localizedCaseInsensitiveContains(searchText) }
                 .filter { selectedSubject == nil || $0.subjectID == selectedSubject }
         }
         
         var body: some View {
             List {
                 ForEach(filteredConversations) { conversation in
                     NavigationLink(destination: VoiceConversationView(viewModel: viewModel, conversationID: conversation.id)) {
                         VStack(alignment: .leading) {
                             Text(conversation.title)
                                 .font(.headline)
                             Text(conversation.updatedAt, style: .date)
                                 .font(.caption)
                         }
                     }
                 }
                 .onDelete(perform: deleteConversations)
             }
             .searchable(text: $searchText)
             .toolbar {
                 ToolbarItem(placement: .navigationBarTrailing) {
                     Menu {
                         Picker("Filter by Subject", selection: $selectedSubject) {
                             Text("All Subjects").tag(nil as UUID?)
                             ForEach(viewModel.subjects) { subject in
                                 Text(subject.name).tag(subject.id as UUID?)
                             }
                         }
                     } label: {
                         Label("Filter", systemImage: "line.3.horizontal.decrease.circle")
                     }
                 }
             }
         }
         
         func deleteConversations(at offsets: IndexSet) {
             for index in offsets {
                 viewModel.deleteConversation(filteredConversations[index].id)
             }
         }
     }
     ```

# Test Strategy:
1. Unit Testing:
   - Create unit tests for VoiceConversation and VoiceMessage models
   - Test CRUD operations in VoiceConversationViewModel
   - Verify proper relationships between models
   - Test filtering and search functionality

2. Integration Testing:
   - Test end-to-end flow from microphone input to persistent storage
   - Verify conversation history loads correctly on app restart
   - Test conversation management features (delete, search, filter)
   - Verify UI updates correctly when messages are added

3. Manual Testing:
   - Record a voice conversation and verify messages appear in the UI
   - Close and reopen the app to verify persistence
   - Create multiple conversations and test navigation between them
   - Test filtering by subject and search functionality
   - Verify delete functionality works correctly
   - Test with various message lengths and content types

4. Performance Testing:
   - Test with large conversation histories (100+ messages)
   - Measure load time for conversation history
   - Verify scrolling performance in the conversation view
   - Test memory usage with multiple active conversations

# Subtasks:
## 1. Define SwiftData Models for Voice Conversations and Messages [done]
### Dependencies: None
### Description: Create and configure SwiftData model classes for VoiceConversation and VoiceMessage, ensuring proper relationships and attributes for persistence.
### Details:
Implement @Model classes for VoiceConversation and VoiceMessage in Core/Models. Ensure VoiceConversation has properties for id, title, createdAt, updatedAt, subjectID, materialID, and a cascade relationship to messages. VoiceMessage should include id, content, isUserMessage, timestamp, and a reference to its parent conversation. Validate model relationships and persistence attributes.

## 2. Integrate SwiftData Queries and CRUD Operations in ViewModel [done]
### Dependencies: 100.1
### Description: Update VoiceConversationViewModel to use SwiftData queries and implement CRUD operations for conversations and messages.
### Details:
Replace any in-memory arrays with @Query properties for VoiceConversation and VoiceMessage. Implement create, read, update, and delete methods for conversations and messages using the modelContext. Ensure that all operations persist data correctly and update the UI as needed.

## 3. Connect Microphone Transcription and AI Responses to Persistence [done]
### Dependencies: 100.2
### Description: Wire up the microphone transcription and AI response callbacks to add messages to the persistent conversation using SwiftData.
### Details:
Modify the microphone button action to call addUserMessage with the transcribed text, and ensure this message is persisted. Update the OpenAIRealtimeClient callback to call addAIMessage, persisting AI responses. Ensure both user and AI messages are correctly linked to the current conversation.

## 4. Load and Display Conversation History in the UI [done]
### Dependencies: 100.3
### Description: Implement logic to load conversation history on view appearance and update the UI to display persisted messages.
### Details:
In VoiceConversationView, load conversations and set the current conversation on appear. Update the ScrollView to display messages from viewModel.currentMessages, ensuring the UI reflects the persisted conversation history.

## 5. Implement Conversation Management and Filtering in the UI [done]
### Dependencies: 100.4
### Description: Create a ConversationListView to manage, search, and filter conversations by subject, and enable deletion of conversations.
### Details:
Develop ConversationListView with search and subject filter capabilities. Implement deletion of conversations and ensure the UI updates accordingly. Integrate with the ViewModel to manage the filtered list and handle navigation to selected conversations.

